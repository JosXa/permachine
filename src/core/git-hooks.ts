import fs from 'node:fs/promises';
import path from 'node:path';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { fileURLToPath } from 'node:url';
import { logger } from '../utils/logger.js';

const execAsync = promisify(exec);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface InstallResult {
  method: 'hooksPath' | 'legacy';
  hooksInstalled: string[];
  warnings: string[];
}

const HOOK_NAMES = ['post-checkout', 'post-merge', 'post-commit'];
const HOOKS_DIR = '.machine-config-sync/hooks';

/**
 * Install git hooks for auto-merging
 */
export async function installHooks(
  options: { legacy?: boolean } = {}
): Promise<InstallResult> {
  const warnings: string[] = [];

  // Check if we're in a git repository
  if (!(await isGitRepository())) {
    throw new Error('Not a git repository. Run "git init" first.');
  }

  const cwd = process.cwd();

  // Check if core.hooksPath is already set
  const existingHooksPath = await getGitConfig('core.hooksPath');
  
  if (existingHooksPath && existingHooksPath !== HOOKS_DIR && !options.legacy) {
    warnings.push(
      `Git core.hooksPath is already set to: ${existingHooksPath}`,
      'Use --legacy flag to install hooks in .git/hooks instead',
    );
  }

  // Determine installation method
  const useLegacy = options.legacy || (existingHooksPath && existingHooksPath !== HOOKS_DIR);

  if (useLegacy) {
    return await installLegacyHooks(warnings);
  } else {
    return await installHooksPathMethod(warnings);
  }
}

/**
 * Install hooks using core.hooksPath method (preferred)
 */
async function installHooksPathMethod(warnings: string[]): Promise<InstallResult> {
  const cwd = process.cwd();
  const hooksDir = path.join(cwd, HOOKS_DIR);

  // Create hooks directory
  await fs.mkdir(hooksDir, { recursive: true });

  // Copy hook templates
  const templatesDir = path.join(__dirname, '../../templates/hooks');
  const installedHooks: string[] = [];

  for (const hookName of HOOK_NAMES) {
    const templatePath = path.join(templatesDir, hookName);
    const hookPath = path.join(hooksDir, hookName);

    const content = await fs.readFile(templatePath, 'utf-8');
    await fs.writeFile(hookPath, content, { mode: 0o755 });
    installedHooks.push(hookName);
  }

  // Set git config
  await setGitConfig('core.hooksPath', HOOKS_DIR);

  logger.success(`Installed git hooks via core.hooksPath`);

  return {
    method: 'hooksPath',
    hooksInstalled: installedHooks,
    warnings,
  };
}

/**
 * Install hooks by wrapping existing .git/hooks (legacy method)
 */
async function installLegacyHooks(warnings: string[]): Promise<InstallResult> {
  const cwd = process.cwd();
  const gitHooksDir = path.join(cwd, '.git/hooks');
  const installedHooks: string[] = [];

  for (const hookName of HOOK_NAMES) {
    const hookPath = path.join(gitHooksDir, hookName);
    const backupPath = path.join(gitHooksDir, `${hookName}.pre-mcs`);

    // Check if hook already exists
    const hookExists = await fileExists(hookPath);
    
    if (hookExists) {
      // Back up existing hook
      await fs.rename(hookPath, backupPath);
    }

    // Create new hook that calls machine-config-sync and then the original hook
    const hookContent = `#!/bin/sh
# Auto-generated by machine-config-sync (legacy mode)

machine-config-sync merge --silent

# Call original hook if it existed
if [ -f "${backupPath}" ]; then
  "${backupPath}" "$@"
fi

exit 0
`;

    await fs.writeFile(hookPath, hookContent, { mode: 0o755 });
    installedHooks.push(hookName);
  }

  logger.success('Installed git hooks via legacy .git/hooks wrapping');

  return {
    method: 'legacy',
    hooksInstalled: installedHooks,
    warnings,
  };
}

/**
 * Uninstall git hooks
 */
export async function uninstallHooks(): Promise<void> {
  const cwd = process.cwd();

  // Check if using hooksPath method
  const hooksPath = await getGitConfig('core.hooksPath');
  
  if (hooksPath === HOOKS_DIR) {
    // Remove hooksPath config
    await execAsync('git config --unset core.hooksPath');
    
    // Remove hooks directory
    const hooksDir = path.join(cwd, HOOKS_DIR);
    await fs.rm(hooksDir, { recursive: true, force: true });
    
    logger.success('Uninstalled git hooks (removed core.hooksPath)');
  } else {
    // Legacy mode - restore original hooks
    const gitHooksDir = path.join(cwd, '.git/hooks');
    
    for (const hookName of HOOK_NAMES) {
      const hookPath = path.join(gitHooksDir, hookName);
      const backupPath = path.join(gitHooksDir, `${hookName}.pre-mcs`);
      
      // Remove our hook
      if (await fileExists(hookPath)) {
        await fs.unlink(hookPath);
      }
      
      // Restore original hook if it existed
      if (await fileExists(backupPath)) {
        await fs.rename(backupPath, hookPath);
      }
    }
    
    logger.success('Uninstalled git hooks (restored original hooks)');
  }
}

/**
 * Check if current directory is a git repository
 */
async function isGitRepository(): Promise<boolean> {
  try {
    await execAsync('git rev-parse --git-dir');
    return true;
  } catch {
    return false;
  }
}

/**
 * Get git config value
 */
async function getGitConfig(key: string): Promise<string | null> {
  try {
    const { stdout } = await execAsync(`git config --get ${key}`);
    return stdout.trim() || null;
  } catch {
    return null;
  }
}

/**
 * Set git config value
 */
async function setGitConfig(key: string, value: string): Promise<void> {
  await execAsync(`git config ${key} "${value}"`);
}

/**
 * Check if file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
